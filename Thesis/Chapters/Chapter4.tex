% Chapter 4

\chapter{Design and Implementation} % Main chapter title

\label{desi} % For referencing the chapter elsewhere, use \ref{desi}

\lhead{Chapter 4. \emph{Design and Implementation}} % This is for the header on each page - perhaps a shortened title
The inclusion of gamification schemes and elements in AnkiDroid required an analysis of its original design. The purpose was finding suitable parts in the structure of the application to integrate gamification components. Once these parts were found, the next step was to define an initial gamification strategy to modify the application. Later, it was necessary to define an approach to include a casual game. Such approach needed to defined a scheme to link the game to reviewing flashcards by means of the initial gamification strategy as seen in Figure \ref{fig:game-elem-cards}. Finally, it was necessary to consider user interface aspects for a smooth integration of the overall solution.

\begin{figure}[htb]
    \vskip 5mm
        \begin{center}
            \includegraphics[scale=0.4]{./Figures/design.png}
            \caption{High level view of the design components and their relations.}
            \label{fig:game-elem-cards}
        \end{center}
    \vskip -5mm
\end{figure}


%----------------------------------------------------------------------------------------
\section{Components of interest in AnkiDroid}
\label{desi-components-interest}
AnkiDroid is a mature application with a clear structure and well defined logic. It has an user interface that follows the best design principles for mobile development. Despite its multiple features and functionalities, the core element is the card reviewer. Here is where the application allows the users benefit from the effects of spaced repetition. The available interactions to review cards permit the user to progress by checking the front of a flashcard, revaling its back, and assessing it, which automatically leads to a new flashcard as seen in Figure \ref{fig:front-back-assess}.

\begin{figure}[htb]
    \vskip 5mm
        \begin{center}
            \includegraphics[scale=0.28]{./Figures/reviewer.png}
            \caption{Flashcard reviewer showing the front, back, front flow.}
            \label{fig:front-back-assess}
        \end{center}
    \vskip -5mm
\end{figure}

Many other secondary components are developed around the revision of cards, being the most relevant the deck picker. This component is the first contact of the user with the application. Its main role is displaying the available decks as seen in Figure \ref{fig:deck-picker}. It also allows several actions on the decks including selection, deletion, and addition. When users select a deck, the application starts the cards revision process. The deck picker connects to other parts of the application like statistics and settings. Finally, the deck picker displays other information including the number of cards and the time reviewing them.

\begin{figure}[htb]
    \vskip 5mm
        \begin{center}
            \includegraphics[scale=0.4]{./Figures/picker.png}
            \caption{Deck picker showing the decks of flashcards.}
            \label{fig:deck-picker}
        \end{center}
    \vskip -5mm
\end{figure}

%----------------------------------------------------------------------------------------
\section{Initial gamification strategy}
\label{desi-gamification-strategy}

The card reviewer and the deck picker present logic and visual characteristics that are relevant for the inclusion of game elements. Therefore, the gamification strategy was centered around the integration of game elements and schemes in both components. The other important design decision was the inclusion of a casual game. Casual games are straightforward and their gameplays allow short periods of play. These characteristics convert casual games in activities that can be executed during work or study breaks. Therefore, the design allowed users to switch from reviewing cards to playing the game at any point.

%----------------------------------------------------------------------------------------
\subsection{Rewards}
In games, a reward is something given to a player as the result of executing a task. In many cases, the objective is motivate the player to do the same task again. In addition, rewards can also be defined as resources for later use, therefore, they can be accumulated. Based on this scheme, a virtual currency was defined in the form of coins. Since the core of the application is the revision of cards, such coins were given to users each time a flashcard was reviewed. Specifically, the number of available coins was increased each time the user assessed a card.

A reward scheme requires the benefit the player receives to be proportional to the effort done. The content of the cards varies from one deck to another it can be as simple as text, or as complex as images and audio. Therefore, the effort exerted in each card is different. Thus, the number of coins granted in each card was defined by the amount of effort. The most suitable way to calculate the effort of users based on the content on cards was by measuring the time spent on them. Hence, the number of coins per card was defined as a function of time. However, a couple of restrictions had to be considered to avoid undesired behaviours from users.

Given that coins were also resources, users could be tempted to obtain them with minimal effort. On potential missbehavior was passing cards as fast as possible to obtain the highest number of possible coins. Moreover, users could intentionally spend more time reviewing cards to obtain more coins. Diminishing these issues required to set ranges of time. Therefore, there were three ranges to calculate the number of coins in each card: null, linear, and constant. The null range was one second long and started the moment a question or an answer was displayed. The linear range was three seconds long and the number of coins were proportional to the amount of time. Finally, the constant range lasted until a new answer or question was displayed and no coins were given.

\begin{equation}
  c(t) =
      \begin{cases}
        0 & \text{if t $\leq$ 1}\\
        t & \text{if 1 $<$ t $\leq$ 3}\\
        3 & \text{if t $>$ 3}\\
      \end{cases}
    \label{eq:coins-formula}
\end{equation}

Equation \ref{eq:coins-formula} describes the calculation of coins, where \textit{c} is the number of coins and \textit{t} is time in seconds. The number of coins was always an integer value. It is important to note that there were minimum and maximum numbers of coins that could be earned in each card, 0 and 6 respectively. A potential drawback when calculating coins was the repetition of a card. AnkiDroid allows to undo the previous reviewed card so that a user can earn additional coins in a single card. However, reviewing the previous flashcard again was not penalized. Hence, the previously earned coins were kept. It is worth to remember that the flashcards are shown to users based on how they assess them, thus, AnkiDroid can display them repeatedly in a short period of time.

Coins could be spent by users to do get some benefits that will be explained later. This dynamic characteristic and how they were calculated could potentially reduce their potential benefits as rewards. Thus, it was necessary to implement a new element with a similar earning scheme but additional characteristics. Points are common elements in games, their objective varies from context to context, but usually they are used as additional rewards and provide information about progress since they are accumulative. Other educational platforms have added points as motivational element \citep{disalvo2014khan}.

Points were designed to be calculated in a similar way to coins. Similarly, there existed ranges of time to earn coins. The first range had the same objective as the one for coins, therefore, its duration was similar. A second range was meant to earn coins proportionally to the time, however, the relation is not linear but logaritmic as seen in Equation \ref{eq:points-formula}, where \textit{p} is the number of points and \textit{t} is time in seconds. Since logaritms are negative for values less than one, a max function between 1 and the logaritm was applied to avoid negative points. Similarly, the number of coins was always an integer value.

The logaritmic relation and the lack of a limit for points had two objectives. First, the creationg of an additional distinction between points and coins. If the number of coins and points in a flashcard were greater than 0, it was unlikely that they were the same value. The second goal had to do with the limit for coins. Since the content of some flashcards could require more time than usual to review it, the maximum number of coins per flashcard acted as a penalization for flashcards with large content. Therefore, the lack of a limit for the number of points earned in a flashcard compensated the coins penalization in large flashcards.

\begin{equation}
  p(t) =
      \begin{cases}
        0 & \text{if t $\leq$ 1}\\
        max(1, 10log(t)) & \text{if t $>$ 1}\\
      \end{cases}
    \label{eq:points-formula}
\end{equation}

%----------------------------------------------------------------------------------------
\subsection{Achievements}
Rewards are by nature obtained after doing small tasks. Several games implements more advanced elements that increase the players' motivation known as achievements. They are similar to rewards, but the main difference is the size of the tasks to get them. Those tasks usually require more time, the execution of a sequence of steps, or the repetition of smaller tasks. The most basic task in AnkiDroid is the revision of flashcards which served to define the achievements scheme, moreover, the accumulative nature of points was also useful in the design.

In the solution, the achievements were designed to be obtained after the repetition of a small task (revision of flashcards). The number of points was used as the element to inform users the progress to reach each achievement. Unlike rewards like coins or points that do not have a limit, achievements were defined as a set of specific elements to be gotten with a specific number of points. Therefore, users were aware about the number of available achievements and the required points to obtain them. Morevover, the application provided information about the reached achievements and the remaining ones.

In addition, to give Ankidroid a more game-like mood, achievements were depicted as pets to be rescued. Those pets were called ankimals, a term that merges the words Anki and animals to provide a sense of identity with the application. The feeling of rescuing pets was complemented with notifications to inform users when a new ankimal was freed. The notifications were designed to encourage the users to rescue more pets by earning more points, therefore, they indirectly asked users to review more flashcards as seen in Figure \ref{fig:ankimals-rescue}.

\begin{figure}[htb]
    \vskip 5mm
        \begin{center}
            \includegraphics[scale=0.5]{./Figures/achievement_notification.png}
            \caption{Notification shown to user when achievement is reached.}
            \label{fig:ankimals-rescue}
        \end{center}
    \vskip -5mm
\end{figure}

%----------------------------------------------------------------------------------------
\subsection{Customization}
Games provide customization aspects to give a more personal experience to players. In the solution, this scheme was defined with two elements. The first one was a nickname that could be set by the user. This element was meant to give a higher sense of participation within the application. The second aspect for a more personal experience was an avatar. It was meant to provide a visual representation of a player which helped to create a sense of individuality. Both elements aimed to create a sense of indentity, but they differed in levels of customization and constraints.

Nicknames were quite customizable and flexible, the only restriction was the maximum number of characters (12). Users were able to set their nicknames at any point. On the opposite, avatars were limited to some images, and users required to get a number of points and icons. Unlike some games and applications where users can use any image to set an avatar, the application allowed users choose one of the rescued ankimals. Moreover, since coins were defined as resources, users needed to spent a number of them to set ankimals as their avatars as seen in Figure \ref{fig:ankimals-select}. An additional level of customization permitted users to color ankimals since they were original depicted in grayscale.

\begin{figure}[htb]
    \vskip 5mm
        \begin{center}
            \includegraphics[scale=0.4]{./Figures/ankimal_selection.png}
            \caption{Dialog to select and color a rescued ankimal.}
            \label{fig:ankimals-select}
        \end{center}
    \vskip -5mm
\end{figure}

%----------------------------------------------------------------------------------------
\subsection{Social and competition}
The informative nature of points was also used to integrate other common element to games: a leaderboard. This component had two objectives, first, it provided a social context to the users. Thus, users knew that there were other people using the application. The second objective was the sense of competition which added another motivational aspect to the revision of flashcards. Even though users of the application were not able communicate to each other directly, and it is unlikely they had any kind of relationship, they were able to see the progress of each other when checking the positions on the leaderboard which were set based on the number of earned points of each user. Finally, the leaderboard displayed the nicknames and avatars as seen in Figure \ref{fig:leaderboard}.

\begin{figure}[htb]
    \vskip 5mm
        \begin{center}
            \includegraphics[scale=0.4]{./Figures/leaderboard.png}
            \caption{Leaderboard showing the nicknames and avatars of users.}
            \label{fig:leaderboard}
        \end{center}
    \vskip -5mm
\end{figure}

%----------------------------------------------------------------------------------------
\subsection{Progress}
Other important components of games are those that give information about progress and other aspects. This scheme was used in the application in the form of a status bar that displayed information about points, coins, rescued ankimals, avatar and nickname. The status bar was set to be displayed in the components of interest of AnkiDroid: deck picker and flashcards reviewer. Additionally, a list of the ankimals was also added in the deck picker to show the rescued and not rescued ankimals as seen in Figure \ref{fig:progress}. This list was also set to allow the selection and coloring of the ankimals.

\begin{figure}[htb]
    \vskip 5mm
        \begin{center}
            \includegraphics[scale=0.4]{./Figures/progress.png}
            \caption{Modified deck picker displaying informative gamification elements.}
            \label{fig:progress}
        \end{center}
    \vskip -5mm
\end{figure}

%----------------------------------------------------------------------------------------
\section{Game integration}
The game needed to be integrated in AnkiDroid in a way that it fitted in the structure. Moreover, the integration required the definition of a linkage between the game an other components of the application. These conditions set the scenario to modify the game and use the previously described gamification elements. The final design set the game as a component with some flexibility to use and smoothly connected to the rest of the application. However, the design also included some contraints aimed to increase the user engagement of flashcards revision.

%----------------------------------------------------------------------------------------
\subsection{Modifications of the game}
2048 is a simple yet challenging game due to the high number of turns to form the block 2048 (1024 turns in the perfect case). Another aspect that increases the difficulty of the game is the limited space, if there are no more empty cells in the grid, and no further movements are possible, then the game is over. Such difficulty along with the need to connect the game with the rest of the application set the starting point to modify the game. Such modifications had to be consistent with the easy-to-use paradigm of casual games. Moreover, they needed to mantain a consistency such their behaviour and results were easy to understand.

Based on the requirements to modify the game, a set of elements were defined to ease the gameplay. Those elements took the form of cheat tricks aimed to provide more alternatives to win. Each trick changed the state of the grid such players had more options in a next move. As mentioned, the state of the grid was defined by the positions of the blocks and their values at a given turn. Therefore, there existed several approaches to change the state of the board. Moreover, each trick needed to provide a different degree of benefit, thus, they were not equally valuable. The modifications included four cheat tricks as seen in Table \ref{tab:tricks}. It is important to note the restrictions to use them based on the state of the grid.

\begin{table*}[!htb]
  \centering
  {\renewcommand{\arraystretch}{2}
    \begin{tabular}{|R{2cm}|R{6cm}|R{5cm}|}
    \hline
    \multicolumn{1}{|>{\centering\arraybackslash}m{2cm}|}{\textbf{Name}} &
    \multicolumn{1}{>{\centering\arraybackslash}m{6cm}|}{\textbf{Benefit}} &
    \multicolumn{1}{>{\centering\arraybackslash}m{5cm}|}{\textbf{Usage conditions}}\\
    \hline
    Gift & Adds a randomly positioned block that can merge with any block which value is less than 512. & There is at least one empty cell in the grid.\\
    \hline
    Doubler & Doubles all the blocks which values are 2. & There is at least one block of value 2 in the grid.\\
    \hline
    Remover & Removes all the blocks which values are 2. & There is at least one block of value 2 in the grid. \newline There is least one block of value greater than 2.\\
    \hline
    Undo & Undoes the last movements (up to 10 previous movements). & There are previous movements.\\
    \hline
    \end{tabular}
  }
  \caption{Cheat tricks for the game, their benefits, and usage conditions}
  \label{tab:tricks}
\end{table*}

%----------------------------------------------------------------------------------------
\subsection{Connection with flashcards revision}
A connecting meant finding existing elements in AnkiDroid that could act as the glue material between the game and revision of cards. In other words, the connection had to be done to include a motivational aspect to encourage user review more cards to obtain benefits in the game. Thus, the user engagement could increase by adapting elements from AnkiDroid to the logic and structure of the game. The original application did not present elements that could be easily adjusted to the game. However, two of the gamification elements defined earlier provided a way to make the connection.

The first elements were points which already provided a motivational aspect in the revision of cards. The informative nature of points was previously used to define achievements in the revision of cards. Following the same scheme, they were also used to define achievements in the game. In this case, the cheat tricks in the game were linked to specific number of points based on the benefits they provided, the higher the benefit the higher the number of points. Therefore, the tricks were initially hid, then, users needed to obtain the corresponding number of points to reveal each trick. Finally, unlike ankimals, users were not notified when a trick was revealed since the main interest was the revision of cards not playing the game.

The number of available tricks was small (4), and revealing each of them was a one time event. This situation could potentially limit the connection between the game and the revision of cards. Therefore, it was necessary to take advantage of coins which were already used as resources to select and color ankimals. In the game, once the tricks were revealed, players could use them at any point as long as they had the required number of coins. In some sense, users needed to buy tricks with the coins they earned reviewing cards. Similarly, a specific number of coins was set for each trick based on the benefit level as seen in Table \ref{tab:tricks-coins-points}.

\begin{table*}[!htb]
  \centering
  {\renewcommand{\arraystretch}{2}
    \begin{tabular}{|R{3cm}|R{3cm}|R{2cm}|R{2cm}|}
    \hline
    \multicolumn{1}{|>{\centering\arraybackslash}m{3cm}|}{\textbf{Cheat trick}} &
    \multicolumn{1}{>{\centering\arraybackslash}m{3cm}|}{\textbf{Benefit level}} &
    \multicolumn{1}{>{\centering\arraybackslash}m{2cm}|}{\textbf{Points}} &
    \multicolumn{1}{>{\centering\arraybackslash}m{2cm}|}{\textbf{Coins}}\\
    \hline
    Gift & Low & 100 & 10\\
    \hline
    Doubler & Medium & 500 & 20\\
    \hline
    Remover & High & 1000 & 30\\
    \hline
    Undo & Higher & 2000 & 40\\
    \hline
    \end{tabular}
  }
  \caption{Costs of cheat tricks in terms of points and coins.}
  \label{tab:tricks-coins-points}
\end{table*}

%----------------------------------------------------------------------------------------
\section{User interface considerations}
Several user interface aspects were considered to implement the game elements described earlier. First, the modifications in the game required the addition of interactive elements for each cheat trick. Initially, color information was used to differentiate the cheat tricks and to provide clues about their status (blocked, enabled, usable)  as seen in Figure \ref{fig:modified-game}. Moreover, since the gameplay of the game required the users to slide vertically and horizontally, cheat tricks could easily be selected by mistake. Avoiding that problem required to design a traslucent curtain to be removed by the user before selecting cheat tricks.

\begin{figure}[htb]
    \vskip 5mm
        \begin{center}
            \includegraphics[scale=0.4]{./Figures/modified_game.png}
            \caption{Modified game showing the cheat tricks with different status at the top of the grid.}
            \label{fig:modified-game}
        \end{center}
    \vskip -5mm
\end{figure}

In AnkiDroid, the main considerations to implement the game elements were related to keep consistency in the overall aspect of the application and the visual clues for the user. The first aspect required to use the same color scheme along with other elements like the font type and size. On the other hand visual clues were meant to provide information about modifications in the game elements. This was done by implementing animations where necessary. For instance, when the number of coins or points changed, animations that updated the corresponding visual elements were implemented. Finally, the visual structure was maitained as much as possible to avoid the new components to be intrusive.


% Move to background
% The selected game was 2048 \citep{uberspot2017game}. It is a puzzle type game with a 4x4 grid as seen in Figure \ref{fig:2048-grid}. The objective of the game is to merge numbered blocks until create one with the value 2048. The game starts with two blocks of value 2 which are randomly positioned in the grid. The player has to slide the blocks horizontally or vertically. The blocks move in the choosen direction; a block stops if it reaches an edge of the grid or collides with another block. If two colliding blocks have the same number, they are merged into a single block which value is the sum of the values of the forming blocks. In every turn, a new block of value 2 is randomly positioned in the grid.

% \begin{figure}[htb]
%     \vskip 5mm
%         \begin{center}
%             \includegraphics[scale=0.5]{./Figures/game_grid.png}
%             \caption{Grid of the 2048 game.}
%             \label{fig:2048-grid}
%         \end{center}
%     \vskip -5mm
% \end{figure}

% % Add to description of game
%  the state of the grid is defined by the positions of the blocks and their values at a given turn

%  % Use this as criticism
%  Evidently, users could play the game without using tricks, but